(() => {
  "use strict";
  const t = {};
  function e(t, e, i) {
    return Math.max(t, Math.min(e, i));
  }
  class i {
    advance(t) {
      if (!this.isRunning) return;
      let i = !1;
      if (this.lerp)
        (this.value =
          ((s = this.value),
          (o = this.to),
          (n = 60 * this.lerp),
          (r = t),
          (function (t, e, i) {
            return (1 - i) * t + i * e;
          })(s, o, 1 - Math.exp(-n * r)))),
          Math.round(this.value) === this.to &&
            ((this.value = this.to), (i = !0));
      else {
        this.currentTime += t;
        const s = e(0, this.currentTime / this.duration, 1);
        i = s >= 1;
        const o = i ? 1 : this.easing(s);
        this.value = this.from + (this.to - this.from) * o;
      }
      var s, o, n, r;
      this.onUpdate?.(this.value, i), i && this.stop();
    }
    stop() {
      this.isRunning = !1;
    }
    fromTo(
      t,
      e,
      {
        lerp: i = 0.1,
        duration: s = 1,
        easing: o = (t) => t,
        onStart: n,
        onUpdate: r,
      }
    ) {
      (this.from = this.value = t),
        (this.to = e),
        (this.lerp = i),
        (this.duration = s),
        (this.easing = o),
        (this.currentTime = 0),
        (this.isRunning = !0),
        n?.(),
        (this.onUpdate = r);
    }
  }
  class s {
    constructor({
      wrapper: t,
      content: e,
      autoResize: i = !0,
      debounce: s = 250,
    } = {}) {
      (this.wrapper = t),
        (this.content = e),
        i &&
          ((this.debouncedResize = (function (t, e) {
            let i;
            return function () {
              let s = arguments,
                o = this;
              clearTimeout(i),
                (i = setTimeout(function () {
                  t.apply(o, s);
                }, e));
            };
          })(this.resize, s)),
          this.wrapper === window
            ? window.addEventListener("resize", this.debouncedResize, !1)
            : ((this.wrapperResizeObserver = new ResizeObserver(
                this.debouncedResize
              )),
              this.wrapperResizeObserver.observe(this.wrapper)),
          (this.contentResizeObserver = new ResizeObserver(
            this.debouncedResize
          )),
          this.contentResizeObserver.observe(this.content)),
        this.resize();
    }
    destroy() {
      this.wrapperResizeObserver?.disconnect(),
        this.contentResizeObserver?.disconnect(),
        window.removeEventListener("resize", this.debouncedResize, !1);
    }
    resize = () => {
      this.onWrapperResize(), this.onContentResize();
    };
    onWrapperResize = () => {
      this.wrapper === window
        ? ((this.width = window.innerWidth), (this.height = window.innerHeight))
        : ((this.width = this.wrapper.clientWidth),
          (this.height = this.wrapper.clientHeight));
    };
    onContentResize = () => {
      this.wrapper === window
        ? ((this.scrollHeight = this.content.scrollHeight),
          (this.scrollWidth = this.content.scrollWidth))
        : ((this.scrollHeight = this.wrapper.scrollHeight),
          (this.scrollWidth = this.wrapper.scrollWidth));
    };
    get limit() {
      return {
        x: this.scrollWidth - this.width,
        y: this.scrollHeight - this.height,
      };
    }
  }
  class o {
    constructor() {
      this.events = {};
    }
    emit(t, ...e) {
      let i = this.events[t] || [];
      for (let t = 0, s = i.length; t < s; t++) i[t](...e);
    }
    on(t, e) {
      return (
        this.events[t]?.push(e) || (this.events[t] = [e]),
        () => {
          this.events[t] = this.events[t]?.filter((t) => e !== t);
        }
      );
    }
    off(t, e) {
      this.events[t] = this.events[t]?.filter((t) => e !== t);
    }
    destroy() {
      this.events = {};
    }
  }
  const n = 100 / 6;
  class r {
    constructor(t, { wheelMultiplier: e = 1, touchMultiplier: i = 1 }) {
      (this.element = t),
        (this.wheelMultiplier = e),
        (this.touchMultiplier = i),
        (this.touchStart = { x: null, y: null }),
        (this.emitter = new o()),
        window.addEventListener("resize", this.onWindowResize, !1),
        this.onWindowResize(),
        this.element.addEventListener("wheel", this.onWheel, { passive: !1 }),
        this.element.addEventListener("touchstart", this.onTouchStart, {
          passive: !1,
        }),
        this.element.addEventListener("touchmove", this.onTouchMove, {
          passive: !1,
        }),
        this.element.addEventListener("touchend", this.onTouchEnd, {
          passive: !1,
        });
    }
    on(t, e) {
      return this.emitter.on(t, e);
    }
    destroy() {
      this.emitter.destroy(),
        window.removeEventListener("resize", this.onWindowResize, !1),
        this.element.removeEventListener("wheel", this.onWheel, {
          passive: !1,
        }),
        this.element.removeEventListener("touchstart", this.onTouchStart, {
          passive: !1,
        }),
        this.element.removeEventListener("touchmove", this.onTouchMove, {
          passive: !1,
        }),
        this.element.removeEventListener("touchend", this.onTouchEnd, {
          passive: !1,
        });
    }
    onTouchStart = (t) => {
      const { clientX: e, clientY: i } = t.targetTouches
        ? t.targetTouches[0]
        : t;
      (this.touchStart.x = e),
        (this.touchStart.y = i),
        (this.lastDelta = { x: 0, y: 0 }),
        this.emitter.emit("scroll", { deltaX: 0, deltaY: 0, event: t });
    };
    onTouchMove = (t) => {
      const { clientX: e, clientY: i } = t.targetTouches
          ? t.targetTouches[0]
          : t,
        s = -(e - this.touchStart.x) * this.touchMultiplier,
        o = -(i - this.touchStart.y) * this.touchMultiplier;
      (this.touchStart.x = e),
        (this.touchStart.y = i),
        (this.lastDelta = { x: s, y: o }),
        this.emitter.emit("scroll", { deltaX: s, deltaY: o, event: t });
    };
    onTouchEnd = (t) => {
      this.emitter.emit("scroll", {
        deltaX: this.lastDelta.x,
        deltaY: this.lastDelta.y,
        event: t,
      });
    };
    onWheel = (t) => {
      let { deltaX: e, deltaY: i, deltaMode: s } = t;
      (e *= 1 === s ? n : 2 === s ? this.windowWidth : 1),
        (i *= 1 === s ? n : 2 === s ? this.windowHeight : 1),
        (e *= this.wheelMultiplier),
        (i *= this.wheelMultiplier),
        this.emitter.emit("scroll", { deltaX: e, deltaY: i, event: t });
    };
    onWindowResize = () => {
      (this.windowWidth = window.innerWidth),
        (this.windowHeight = window.innerHeight);
    };
  }
  class l {
    constructor({
      wrapper: t = window,
      content: e = document.documentElement,
      wheelEventsTarget: n = t,
      eventsTarget: l = n,
      smoothWheel: a = !0,
      syncTouch: c = !1,
      syncTouchLerp: h = 0.075,
      touchInertiaMultiplier: d = 35,
      duration: u,
      easing: m = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
      lerp: p = !u && 0.1,
      infinite: g = !1,
      orientation: w = "vertical",
      gestureOrientation: v = "vertical",
      touchMultiplier: f = 1,
      wheelMultiplier: S = 1,
      autoResize: L = !0,
      __experimental__naiveDimensions: y = !1,
    } = {}) {
      (this.__isSmooth = !1),
        (this.__isScrolling = !1),
        (this.__isStopped = !1),
        (this.__isLocked = !1),
        (this.onVirtualScroll = ({ deltaX: t, deltaY: e, event: i }) => {
          if (i.ctrlKey) return;
          const s = i.type.includes("touch"),
            o = i.type.includes("wheel");
          if (
            this.options.syncTouch &&
            s &&
            "touchstart" === i.type &&
            !this.isStopped &&
            !this.isLocked
          )
            return void this.reset();
          const n = 0 === t && 0 === e,
            r =
              ("vertical" === this.options.gestureOrientation && 0 === e) ||
              ("horizontal" === this.options.gestureOrientation && 0 === t);
          if (n || r) return;
          let l = i.composedPath();
          if (
            ((l = l.slice(0, l.indexOf(this.rootElement))),
            l.find((t) => {
              var e, i, n, r, l;
              return (
                (null === (e = t.hasAttribute) || void 0 === e
                  ? void 0
                  : e.call(t, "data-lenis-prevent")) ||
                (s &&
                  (null === (i = t.hasAttribute) || void 0 === i
                    ? void 0
                    : i.call(t, "data-lenis-prevent-touch"))) ||
                (o &&
                  (null === (n = t.hasAttribute) || void 0 === n
                    ? void 0
                    : n.call(t, "data-lenis-prevent-wheel"))) ||
                ((null === (r = t.classList) || void 0 === r
                  ? void 0
                  : r.contains("lenis")) &&
                  !(null === (l = t.classList) || void 0 === l
                    ? void 0
                    : l.contains("lenis-stopped")))
              );
            }))
          )
            return;
          if (this.isStopped || this.isLocked) return void i.preventDefault();
          if (
            ((this.isSmooth =
              (this.options.syncTouch && s) || (this.options.smoothWheel && o)),
            !this.isSmooth)
          )
            return (this.isScrolling = !1), void this.animate.stop();
          i.preventDefault();
          let a = e;
          "both" === this.options.gestureOrientation
            ? (a = Math.abs(e) > Math.abs(t) ? e : t)
            : "horizontal" === this.options.gestureOrientation && (a = t);
          const c = s && this.options.syncTouch,
            h = s && "touchend" === i.type && Math.abs(a) > 5;
          h && (a = this.velocity * this.options.touchInertiaMultiplier),
            this.scrollTo(
              this.targetScroll + a,
              Object.assign(
                { programmatic: !1 },
                c
                  ? { lerp: h ? this.options.syncTouchLerp : 1 }
                  : {
                      lerp: this.options.lerp,
                      duration: this.options.duration,
                      easing: this.options.easing,
                    }
              )
            );
        }),
        (this.onNativeScroll = () => {
          if (!this.__preventNextScrollEvent && !this.isScrolling) {
            const t = this.animatedScroll;
            (this.animatedScroll = this.targetScroll = this.actualScroll),
              (this.velocity = 0),
              (this.direction = Math.sign(this.animatedScroll - t)),
              this.emit();
          }
        }),
        (window.lenisVersion = "1.0.42"),
        (t !== document.documentElement && t !== document.body) || (t = window),
        (this.options = {
          wrapper: t,
          content: e,
          wheelEventsTarget: n,
          eventsTarget: l,
          smoothWheel: a,
          syncTouch: c,
          syncTouchLerp: h,
          touchInertiaMultiplier: d,
          duration: u,
          easing: m,
          lerp: p,
          infinite: g,
          gestureOrientation: v,
          orientation: w,
          touchMultiplier: f,
          wheelMultiplier: S,
          autoResize: L,
          __experimental__naiveDimensions: y,
        }),
        (this.animate = new i()),
        (this.emitter = new o()),
        (this.dimensions = new s({ wrapper: t, content: e, autoResize: L })),
        this.toggleClassName("lenis", !0),
        (this.velocity = 0),
        (this.isLocked = !1),
        (this.isStopped = !1),
        (this.isSmooth = c || a),
        (this.isScrolling = !1),
        (this.targetScroll = this.animatedScroll = this.actualScroll),
        this.options.wrapper.addEventListener(
          "scroll",
          this.onNativeScroll,
          !1
        ),
        (this.virtualScroll = new r(l, {
          touchMultiplier: f,
          wheelMultiplier: S,
        })),
        this.virtualScroll.on("scroll", this.onVirtualScroll);
    }
    destroy() {
      this.emitter.destroy(),
        this.options.wrapper.removeEventListener(
          "scroll",
          this.onNativeScroll,
          !1
        ),
        this.virtualScroll.destroy(),
        this.dimensions.destroy(),
        this.toggleClassName("lenis", !1),
        this.toggleClassName("lenis-smooth", !1),
        this.toggleClassName("lenis-scrolling", !1),
        this.toggleClassName("lenis-stopped", !1),
        this.toggleClassName("lenis-locked", !1);
    }
    on(t, e) {
      return this.emitter.on(t, e);
    }
    off(t, e) {
      return this.emitter.off(t, e);
    }
    setScroll(t) {
      this.isHorizontal
        ? (this.rootElement.scrollLeft = t)
        : (this.rootElement.scrollTop = t);
    }
    resize() {
      this.dimensions.resize();
    }
    emit() {
      this.emitter.emit("scroll", this);
    }
    reset() {
      (this.isLocked = !1),
        (this.isScrolling = !1),
        (this.animatedScroll = this.targetScroll = this.actualScroll),
        (this.velocity = 0),
        this.animate.stop();
    }
    start() {
      this.isStopped && ((this.isStopped = !1), this.reset());
    }
    stop() {
      this.isStopped ||
        ((this.isStopped = !0), this.animate.stop(), this.reset());
    }
    raf(t) {
      const e = t - (this.time || t);
      (this.time = t), this.animate.advance(0.001 * e);
    }
    scrollTo(
      t,
      {
        offset: i = 0,
        immediate: s = !1,
        lock: o = !1,
        duration: n = this.options.duration,
        easing: r = this.options.easing,
        lerp: l = !n && this.options.lerp,
        onComplete: a,
        force: c = !1,
        programmatic: h = !0,
      } = {}
    ) {
      if ((!this.isStopped && !this.isLocked) || c) {
        if (["top", "left", "start"].includes(t)) t = 0;
        else if (["bottom", "right", "end"].includes(t)) t = this.limit;
        else {
          let e;
          if (
            ("string" == typeof t
              ? (e = document.querySelector(t))
              : (null == t ? void 0 : t.nodeType) && (e = t),
            e)
          ) {
            if (this.options.wrapper !== window) {
              const t = this.options.wrapper.getBoundingClientRect();
              i -= this.isHorizontal ? t.left : t.top;
            }
            const s = e.getBoundingClientRect();
            t = (this.isHorizontal ? s.left : s.top) + this.animatedScroll;
          }
        }
        if ("number" == typeof t) {
          if (
            ((t += i),
            (t = Math.round(t)),
            this.options.infinite
              ? h && (this.targetScroll = this.animatedScroll = this.scroll)
              : (t = e(0, t, this.limit)),
            s)
          )
            return (
              (this.animatedScroll = this.targetScroll = t),
              this.setScroll(this.scroll),
              this.reset(),
              void (null == a || a(this))
            );
          if (!h) {
            if (t === this.targetScroll) return;
            this.targetScroll = t;
          }
          this.animate.fromTo(this.animatedScroll, t, {
            duration: n,
            easing: r,
            lerp: l,
            onStart: () => {
              o && (this.isLocked = !0), (this.isScrolling = !0);
            },
            onUpdate: (t, e) => {
              (this.isScrolling = !0),
                (this.velocity = t - this.animatedScroll),
                (this.direction = Math.sign(this.velocity)),
                (this.animatedScroll = t),
                this.setScroll(this.scroll),
                h && (this.targetScroll = t),
                e || this.emit(),
                e &&
                  (this.reset(),
                  this.emit(),
                  null == a || a(this),
                  (this.__preventNextScrollEvent = !0),
                  requestAnimationFrame(() => {
                    delete this.__preventNextScrollEvent;
                  }));
            },
          });
        }
      }
    }
    get rootElement() {
      return this.options.wrapper === window
        ? document.documentElement
        : this.options.wrapper;
    }
    get limit() {
      return this.options.__experimental__naiveDimensions
        ? this.isHorizontal
          ? this.rootElement.scrollWidth - this.rootElement.clientWidth
          : this.rootElement.scrollHeight - this.rootElement.clientHeight
        : this.dimensions.limit[this.isHorizontal ? "x" : "y"];
    }
    get isHorizontal() {
      return "horizontal" === this.options.orientation;
    }
    get actualScroll() {
      return this.isHorizontal
        ? this.rootElement.scrollLeft
        : this.rootElement.scrollTop;
    }
    get scroll() {
      return this.options.infinite
        ? ((this.animatedScroll % (t = this.limit)) + t) % t
        : this.animatedScroll;
      var t;
    }
    get progress() {
      return 0 === this.limit ? 1 : this.scroll / this.limit;
    }
    get isSmooth() {
      return this.__isSmooth;
    }
    set isSmooth(t) {
      this.__isSmooth !== t &&
        ((this.__isSmooth = t), this.toggleClassName("lenis-smooth", t));
    }
    get isScrolling() {
      return this.__isScrolling;
    }
    set isScrolling(t) {
      this.__isScrolling !== t &&
        ((this.__isScrolling = t), this.toggleClassName("lenis-scrolling", t));
    }
    get isStopped() {
      return this.__isStopped;
    }
    set isStopped(t) {
      this.__isStopped !== t &&
        ((this.__isStopped = t), this.toggleClassName("lenis-stopped", t));
    }
    get isLocked() {
      return this.__isLocked;
    }
    set isLocked(t) {
      this.__isLocked !== t &&
        ((this.__isLocked = t), this.toggleClassName("lenis-locked", t));
    }
    get className() {
      let t = "lenis";
      return (
        this.isStopped && (t += " lenis-stopped"),
        this.isLocked && (t += " lenis-locked"),
        this.isScrolling && (t += " lenis-scrolling"),
        this.isSmooth && (t += " lenis-smooth"),
        t
      );
    }
    toggleClassName(t, e) {
      this.rootElement.classList.toggle(t, e),
        this.emitter.emit("className change", this);
    }
  }
  let a = {
    Android: function () {
      return navigator.userAgent.match(/Android/i);
    },
    BlackBerry: function () {
      return navigator.userAgent.match(/BlackBerry/i);
    },
    iOS: function () {
      return navigator.userAgent.match(/iPhone|iPad|iPod/i);
    },
    Opera: function () {
      return navigator.userAgent.match(/Opera Mini/i);
    },
    Windows: function () {
      return navigator.userAgent.match(/IEMobile/i);
    },
    any: function () {
      return (
        a.Android() || a.BlackBerry() || a.iOS() || a.Opera() || a.Windows()
      );
    },
  };
  function c() {
    if (location.hash) return location.hash.replace("#", "");
  }
  let h = !0,
    d = (t = 500) => {
      if (h) {
        const e = document.querySelectorAll("[data-lp]");
        setTimeout(() => {
          e.forEach((t) => {
            t.style.paddingRight = "";
          }),
            (document.body.style.paddingRight = ""),
            document.documentElement.classList.remove("lock"),
            window.onRefreshLenisScroll && window.onRefreshLenisScroll();
        }, t),
          (h = !1),
          setTimeout(function () {
            h = !0;
          }, t);
      }
    },
    u = (t = 500) => {
      if (h) {
        const e = document.querySelectorAll("[data-lp]"),
          i = window.innerWidth - document.body.offsetWidth + "px";
        e.forEach((t) => {
          t.style.paddingRight = i;
        }),
          (document.body.style.paddingRight = i),
          document.documentElement.classList.add("lock"),
          window.lenis?.destroy(),
          (h = !1),
          setTimeout(function () {
            h = !0;
          }, t);
      }
    };
  function m() {
    d(),
      document.documentElement.classList.add("menu-close"),
      document.documentElement.classList.remove("menu-open");
  }
  function p(t) {
    setTimeout(() => {
      window.FLS && console.log(t);
    }, 0);
  }
  function g(t) {
    return t.filter(function (t, e, i) {
      return i.indexOf(t) === e;
    });
  }
  if (!window.navigator.userAgent.match(/Trident\/7\./, [])) {
    const t = document.querySelectorAll("video");
    !(function () {
      const t = window.navigator,
        e = t.userAgent.toLowerCase(),
        i = !(!t.mediaCapabilities || !t.mediaCapabilities.decodingInfo);
      return (
        -1 != e.indexOf("safari") &&
        !(-1 != e.indexOf("chrome")) &&
        -1 != e.indexOf("version/") &&
        i
      );
    })()
      ? t.forEach((t) => {
          let e = t.getAttribute("src");
          (e += "webm"), t.setAttribute("src", e);
        })
      : t.forEach((t) => {
          let e = t.getAttribute("src");
          (e += "mov"),
            t.setAttribute("src", e),
            t.setAttribute("type", "video/quicktime");
        });
  }
  window.onRefreshLenisScroll = () => {
    window.lenis?.destroy(),
      setTimeout(() => {
        (window.lenis = new l({
          eventsTarget: document.querySelector("main"),
          duration: 1.2,
          infinite: !1,
          autoResize: !0,
        })),
          requestAnimationFrame(function t(e) {
            window.lenis.raf(e), requestAnimationFrame(t);
          });
      }, 0);
  };
  let w = (t, e = !1, i = 500, s = 0) => {
    const o = document.querySelector(t);
    if (o) {
      let n = "",
        r = 0;
      if (e) {
        n = "header.header";
        const t = document.querySelector(n);
        t.classList.contains("_header-scroll")
          ? (r = t.offsetHeight)
          : ((t.style.cssText = "transition-duration: 0s;"),
            t.classList.add("_header-scroll"),
            (r = t.offsetHeight),
            t.classList.remove("_header-scroll"),
            setTimeout(() => {
              t.style.cssText = "";
            }, 0));
      }
      let l = {
        speedAsDuration: !0,
        speed: i,
        header: n,
        offset: s,
        easing: "easeOutQuad",
      };
      if (
        (document.documentElement.classList.contains("menu-open") && m(),
        "undefined" != typeof SmoothScroll)
      )
        new SmoothScroll().animateScroll(o, "", l);
      else {
        let t = o.getBoundingClientRect().top + scrollY;
        (t = r ? t - r : t),
          (t = s ? t - s : t),
          window.scrollTo({ top: t, behavior: "smooth" });
      }
      p(`[gotoBlock]: Юхуу...їдемо до ${t}`);
    } else p(`[gotoBlock]: Йой... Такого блоку немає на сторінці: ${t}`);
  };
  t.watcher = new (class {
    constructor(t) {
      (this.config = Object.assign({ logging: !0 }, t)),
        this.observer,
        !document.documentElement.classList.contains("watcher") &&
          this.scrollWatcherRun();
    }
    scrollWatcherUpdate() {
      this.scrollWatcherRun();
    }
    scrollWatcherRun() {
      document.documentElement.classList.add("watcher"),
        this.scrollWatcherConstructor(
          document.querySelectorAll("[data-watch]")
        );
    }
    scrollWatcherConstructor(t) {
      if (t.length) {
        this.scrollWatcherLogging(
          `Прокинувся, стежу за об'єктами (${t.length})...`
        ),
          g(
            Array.from(t).map(function (t) {
              if (
                "navigator" === t.dataset.watch &&
                !t.dataset.watchThreshold
              ) {
                let e;
                t.clientHeight > 2
                  ? ((e = window.innerHeight / 2 / (t.clientHeight - 1)),
                    e > 1 && (e = 1))
                  : (e = 1),
                  t.setAttribute("data-watch-threshold", e.toFixed(2));
              }
              return `${
                t.dataset.watchRoot ? t.dataset.watchRoot : null
              }|${t.dataset.watchMargin ? t.dataset.watchMargin : "0px"}|${t.dataset.watchThreshold ? t.dataset.watchThreshold : 0}`;
            })
          ).forEach((e) => {
            let i = e.split("|"),
              s = { root: i[0], margin: i[1], threshold: i[2] },
              o = Array.from(t).filter(function (t) {
                let e = t.dataset.watchRoot ? t.dataset.watchRoot : null,
                  i = t.dataset.watchMargin ? t.dataset.watchMargin : "0px",
                  o = t.dataset.watchThreshold ? t.dataset.watchThreshold : 0;
                if (
                  String(e) === s.root &&
                  String(i) === s.margin &&
                  String(o) === s.threshold
                )
                  return t;
              }),
              n = this.getScrollWatcherConfig(s);
            this.scrollWatcherInit(o, n);
          });
      } else
        this.scrollWatcherLogging("Сплю, немає об'єктів для стеження. ZzzZZzz");
    }
    getScrollWatcherConfig(t) {
      let e = {};
      if (
        (document.querySelector(t.root)
          ? (e.root = document.querySelector(t.root))
          : "null" !== t.root &&
            this.scrollWatcherLogging(
              `Эмм... батьківського об'єкта ${t.root} немає на сторінці`
            ),
        (e.rootMargin = t.margin),
        !(t.margin.indexOf("px") < 0 && t.margin.indexOf("%") < 0))
      ) {
        if ("prx" === t.threshold) {
          t.threshold = [];
          for (let e = 0; e <= 1; e += 0.005) t.threshold.push(e);
        } else t.threshold = t.threshold.split(",");
        return (e.threshold = t.threshold), e;
      }
      this.scrollWatcherLogging(
        "йой, налаштування data-watch-margin потрібно задавати в PX або %"
      );
    }
    scrollWatcherCreate(t) {
      this.observer = new IntersectionObserver((t, e) => {
        t.forEach((t) => {
          this.scrollWatcherCallback(t, e);
        });
      }, t);
    }
    scrollWatcherInit(t, e) {
      this.scrollWatcherCreate(e), t.forEach((t) => this.observer.observe(t));
    }
    scrollWatcherIntersecting(t, e) {
      t.isIntersecting
        ? (!e.classList.contains("_watcher-view") &&
            e.classList.add("_watcher-view"),
          this.scrollWatcherLogging(
            `Я бачу ${e.classList}, додав клас _watcher-view`
          ))
        : (e.classList.contains("_watcher-view") &&
            e.classList.remove("_watcher-view"),
          this.scrollWatcherLogging(
            `Я не бачу ${e.classList}, прибрав клас _watcher-view`
          ));
    }
    scrollWatcherOff(t, e) {
      e.unobserve(t),
        this.scrollWatcherLogging(`Я перестав стежити за ${t.classList}`);
    }
    scrollWatcherLogging(t) {
      this.config.logging && p(`[Спостерігач]: ${t}`);
    }
    scrollWatcherCallback(t, e) {
      const i = t.target;
      this.scrollWatcherIntersecting(t, i),
        i.hasAttribute("data-watch-once") &&
          t.isIntersecting &&
          this.scrollWatcherOff(i, e),
        document.dispatchEvent(
          new CustomEvent("watcherCallback", { detail: { entry: t } })
        );
    }
  })({});
  let v = !1;
  setTimeout(() => {
    if (v) {
      let t = new Event("windowScroll");
      window.addEventListener("scroll", function (e) {
        document.dispatchEvent(t);
      });
    }
  }, 0);
  new (class {
    constructor(t) {
      this.type = t;
    }
    init() {
      (this.оbjects = []),
        (this.daClassname = "_dynamic_adapt_"),
        (this.nodes = [...document.querySelectorAll("[data-da]")]),
        this.nodes.forEach((t) => {
          const e = t.dataset.da.trim().split(","),
            i = {};
          (i.element = t),
            (i.parent = t.parentNode),
            (i.destination = document.querySelector(`${e[0].trim()}`)),
            (i.breakpoint = e[1] ? e[1].trim() : "767.98"),
            (i.place = e[2] ? e[2].trim() : "last"),
            (i.index = this.indexInParent(i.parent, i.element)),
            this.оbjects.push(i);
        }),
        this.arraySort(this.оbjects),
        (this.mediaQueries = this.оbjects
          .map(({ breakpoint: t }) => `(${this.type}-width: ${t / 16}em),${t}`)
          .filter((t, e, i) => i.indexOf(t) === e)),
        this.mediaQueries.forEach((t) => {
          const e = t.split(","),
            i = window.matchMedia(e[0]),
            s = e[1],
            o = this.оbjects.filter(({ breakpoint: t }) => t === s);
          i.addEventListener("change", () => {
            this.mediaHandler(i, o);
          }),
            this.mediaHandler(i, o);
        });
    }
    mediaHandler(t, e) {
      t.matches
        ? e.forEach((t) => {
            this.moveTo(t.place, t.element, t.destination);
          })
        : e.forEach(({ parent: t, element: e, index: i }) => {
            e.classList.contains(this.daClassname) && this.moveBack(t, e, i);
          });
    }
    moveTo(t, e, i) {
      e.classList.add(this.daClassname),
        "last" === t || t >= i.children.length
          ? i.append(e)
          : "first" !== t
          ? i.children[t].before(e)
          : i.prepend(e);
    }
    moveBack(t, e, i) {
      e.classList.remove(this.daClassname),
        void 0 !== t.children[i] ? t.children[i].before(e) : t.append(e);
    }
    indexInParent(t, e) {
      return [...t.children].indexOf(e);
    }
    arraySort(t) {
      "min" === this.type
        ? t.sort((t, e) =>
            t.breakpoint === e.breakpoint
              ? t.place === e.place
                ? 0
                : "first" === t.place || "last" === e.place
                ? -1
                : "last" === t.place || "first" === e.place
                ? 1
                : 0
              : t.breakpoint - e.breakpoint
          )
        : t.sort((t, e) =>
            t.breakpoint === e.breakpoint
              ? t.place === e.place
                ? 0
                : "first" === t.place || "last" === e.place
                ? 1
                : "last" === t.place || "first" === e.place
                ? -1
                : 0
              : e.breakpoint - t.breakpoint
          );
    }
  })("max").init(),
    document.documentElement.classList.contains("loading") ||
      window.addEventListener("load", function () {
        setTimeout(function () {
          document.documentElement.classList.add("loaded");
        }, 0);
      }),
    document.querySelector(".icon-menu") &&
      document.addEventListener("click", function (t) {
        h &&
          t.target.closest(".icon-menu") &&
          (((t = 500) => {
            document.documentElement.classList.contains("lock") ? d(t) : u(t);
          })(),
          document.documentElement.classList.contains("menu-open")
            ? m()
            : (u(),
              document.documentElement.classList.add("menu-open"),
              document.documentElement.classList.remove("menu-close")));
      }),
    (function () {
      const t = document.querySelectorAll("[data-clipboardBtn]");
      t.length &&
        t.forEach((t) => {
          t.addEventListener("click", () => {
            const e = t.closest("[data-clipboard]");
            if (e) {
              const i = e
                  .querySelector("[data-clipboardEl]")
                  .textContent.trim(),
                s = e.querySelector("[data-cnHint]");
              async function o(t) {
                try {
                  await navigator.clipboard.writeText(t);
                } catch (t) {
                  s.textContent = "Doesn't copied";
                } finally {
                  setTimeout(() => {
                    e.classList.remove("active");
                  }, 1e3);
                }
              }
              e.classList.add("active"), o(i);
            }
          });
        });
    })(),
    (function () {
      function e(e) {
        if ("click" === e.type) {
          const i = e.target;
          if (i.closest("[data-goto]")) {
            const s = i.closest("[data-goto]"),
              o = s.dataset.goto ? s.dataset.goto : "",
              n = !!s.hasAttribute("data-goto-header"),
              r = s.dataset.gotoSpeed ? s.dataset.gotoSpeed : 500,
              l = s.dataset.gotoTop ? parseInt(s.dataset.gotoTop) : 0;
            if (t.fullpage) {
              const e = document
                  .querySelector(`${o}`)
                  .closest("[data-fp-section]"),
                i = e ? +e.dataset.fpId : null;
              null !== i &&
                (t.fullpage.switchingSection(i),
                document.documentElement.classList.contains("menu-open") &&
                  m());
            } else w(o, n, r, l);
            e.preventDefault();
          }
        } else if ("watcherCallback" === e.type && e.detail) {
          const t = e.detail.entry,
            i = t.target;
          if ("navigator" === i.dataset.watch) {
            document.querySelector("[data-goto]._navigator-active");
            let e;
            if (i.id && document.querySelector(`[data-goto="#${i.id}"]`))
              e = document.querySelector(`[data-goto="#${i.id}"]`);
            else if (i.classList.length)
              for (let t = 0; t < i.classList.length; t++) {
                const s = i.classList[t];
                if (document.querySelector(`[data-goto=".${s}"]`)) {
                  e = document.querySelector(`[data-goto=".${s}"]`);
                  break;
                }
              }
            t.isIntersecting
              ? e && e.classList.add("_navigator-active")
              : e && e.classList.remove("_navigator-active");
          }
        }
      }
      if (
        (document.addEventListener("click", e),
        document.addEventListener("watcherCallback", e),
        c())
      ) {
        let t;
        document.querySelector(`#${c()}`)
          ? (t = `#${c()}`)
          : document.querySelector(`.${c()}`) && (t = `.${c()}`),
          t && w(t, !0, 500, 20);
      }
    })(),
    (function () {
      v = !0;
      const t = document.querySelector("header.header"),
        e = t.hasAttribute("data-scroll-show"),
        i = t.dataset.scrollShow ? t.dataset.scrollShow : 500,
        s = t.dataset.scroll ? t.dataset.scroll : 1;
      let o,
        n = 0;
      document.addEventListener("windowScroll", function (r) {
        const l = window.scrollY;
        clearTimeout(o),
          l >= s
            ? (!t.classList.contains("_header-scroll") &&
                t.classList.add("_header-scroll"),
              e &&
                (l > n
                  ? t.classList.contains("_header-show") &&
                    t.classList.remove("_header-show")
                  : !t.classList.contains("_header-show") &&
                    t.classList.add("_header-show"),
                (o = setTimeout(() => {
                  !t.classList.contains("_header-show") &&
                    t.classList.add("_header-show");
                }, i))))
            : (t.classList.contains("_header-scroll") &&
                t.classList.remove("_header-scroll"),
              e &&
                t.classList.contains("_header-show") &&
                t.classList.remove("_header-show")),
          (n = l <= 0 ? 0 : l);
      });
    })(),
    !a.any() && window.onRefreshLenisScroll();
})();
